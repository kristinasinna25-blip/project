import random
import time


class Graph:
    def init(self, n, mode='list'):
        self.n = n
        self.mode = mode
        self.aij = [set() for _ in range(n)]
        self.matrix = [[0] * n for _ in range(n)]

    def plus_edge(self, u, v):
        if u != v:
            self.aij[v].add(u)
            self.aij[u].add(v)
            self.matrix[u][v] = 1
            self.matrix[v][u] = 1

    def neighbors(self, v, ):
        if self.mode == 'list':
            return self.aij[v]
        elif self.mode == 'matrix':
            neighs = set()
            for i in range(self.n):
                if self.matrix[v][i] == 1:
                    neighs.add(i)
            return neighs
        return set()

    def bron_kerbosch(self, R, P, X, cliques):
        if not P and not X:
            cliques.append(R)
            return

        # Використовуємо list(P), щоб створити копію для ітерації,
        # бо P змінюється всередині циклу
        for v in list(P):
            self.bron_kerbosch(
                R | {v},
                P & self.neighbors(v),
                X & self.neighbors(v),
                cliques
            )
            P.remove(v)
            X.add(v)

    def main(self):
        result = []
        self.bron_kerbosch(set(), set(range(self.n)), set(), result)
        return result

    @staticmethod
    def random_graph(n, density, mode='list'):
        g = Graph(n, mode)
        # Оптимізація: генеруємо ребра
        for i in range(n):
            for j in range(i + 1, n):
                if random.random() < density:
                    g.plus_edge(i, j)
        return g



def run_automated_experiments():

    sizes = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    densities = [0.1, 0.3, 0.5, 0.6, 0.7]
    repeats = 20

    results_table = []

    print(f"{'Density':<10} | {'Size (N)':<10} | {'Avg Time List (s)':<20} | {'Avg Time Matrix (s)':<20}")
    print("-" * 70)

    for density in densities:
        for n in sizes:
            total_time_list = 0
            total_time_matrix = 0

            for _ in range(repeats):
                g_list = Graph.random_graph(n, density, mode='list')

                start = time.time()
                g_list.main()
                total_time_list += (time.time() - start)

                g_matrix = Graph.random_graph(n, density, mode='matrix')

                start = time.time()
                g_matrix.main()
                total_time_matrix += (time.time() - start)

            avg_list = total_time_list / repeats
            avg_matrix = total_time_matrix / repeats

            results_table.append({
                "Density": density,
                "Size": n,
                "Time_List": avg_list,
                "Time_Matrix": avg_matrix
            })

            print(f"{density:<10} | {n:<10} | {avg_list:<20.6f} | {avg_matrix:<20.6f}")

    return results_table


if name == "main":
    data = run_automated_experiments()
